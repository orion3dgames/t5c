import { pack } from "msgpackr";
import { encode } from "@colyseus/schema";
import { logger } from "./Logger";
var Protocol = /* @__PURE__ */ ((Protocol2) => {
  Protocol2[Protocol2["JOIN_ROOM"] = 10] = "JOIN_ROOM";
  Protocol2[Protocol2["ERROR"] = 11] = "ERROR";
  Protocol2[Protocol2["LEAVE_ROOM"] = 12] = "LEAVE_ROOM";
  Protocol2[Protocol2["ROOM_DATA"] = 13] = "ROOM_DATA";
  Protocol2[Protocol2["ROOM_STATE"] = 14] = "ROOM_STATE";
  Protocol2[Protocol2["ROOM_STATE_PATCH"] = 15] = "ROOM_STATE_PATCH";
  Protocol2[Protocol2["ROOM_DATA_SCHEMA"] = 16] = "ROOM_DATA_SCHEMA";
  Protocol2[Protocol2["ROOM_DATA_BYTES"] = 17] = "ROOM_DATA_BYTES";
  Protocol2[Protocol2["WS_CLOSE_NORMAL"] = 1e3] = "WS_CLOSE_NORMAL";
  Protocol2[Protocol2["WS_CLOSE_CONSENTED"] = 4e3] = "WS_CLOSE_CONSENTED";
  Protocol2[Protocol2["WS_CLOSE_WITH_ERROR"] = 4002] = "WS_CLOSE_WITH_ERROR";
  Protocol2[Protocol2["WS_CLOSE_DEVMODE_RESTART"] = 4010] = "WS_CLOSE_DEVMODE_RESTART";
  Protocol2[Protocol2["WS_SERVER_DISCONNECT"] = 4201] = "WS_SERVER_DISCONNECT";
  Protocol2[Protocol2["WS_TOO_MANY_CLIENTS"] = 4202] = "WS_TOO_MANY_CLIENTS";
  return Protocol2;
})(Protocol || {});
var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2[ErrorCode2["MATCHMAKE_NO_HANDLER"] = 4210] = "MATCHMAKE_NO_HANDLER";
  ErrorCode2[ErrorCode2["MATCHMAKE_INVALID_CRITERIA"] = 4211] = "MATCHMAKE_INVALID_CRITERIA";
  ErrorCode2[ErrorCode2["MATCHMAKE_INVALID_ROOM_ID"] = 4212] = "MATCHMAKE_INVALID_ROOM_ID";
  ErrorCode2[ErrorCode2["MATCHMAKE_UNHANDLED"] = 4213] = "MATCHMAKE_UNHANDLED";
  ErrorCode2[ErrorCode2["MATCHMAKE_EXPIRED"] = 4214] = "MATCHMAKE_EXPIRED";
  ErrorCode2[ErrorCode2["AUTH_FAILED"] = 4215] = "AUTH_FAILED";
  ErrorCode2[ErrorCode2["APPLICATION_ERROR"] = 4216] = "APPLICATION_ERROR";
  return ErrorCode2;
})(ErrorCode || {});
var IpcProtocol = /* @__PURE__ */ ((IpcProtocol2) => {
  IpcProtocol2[IpcProtocol2["SUCCESS"] = 0] = "SUCCESS";
  IpcProtocol2[IpcProtocol2["ERROR"] = 1] = "ERROR";
  IpcProtocol2[IpcProtocol2["TIMEOUT"] = 2] = "TIMEOUT";
  return IpcProtocol2;
})(IpcProtocol || {});
const getMessageBytes = {
  [10 /* JOIN_ROOM */]: (reconnectionToken, serializerId, handshake) => {
    let offset = 0;
    const reconnectionTokenLength = utf8Length(reconnectionToken);
    const serializerIdLength = utf8Length(serializerId);
    const handshakeLength = handshake ? handshake.length : 0;
    const buff = Buffer.allocUnsafe(1 + reconnectionTokenLength + serializerIdLength + handshakeLength);
    buff.writeUInt8(10 /* JOIN_ROOM */, offset++);
    utf8Write(buff, offset, reconnectionToken);
    offset += reconnectionTokenLength;
    utf8Write(buff, offset, serializerId);
    offset += serializerIdLength;
    if (handshake) {
      for (let i = 0, l = handshake.length; i < l; i++) {
        buff.writeUInt8(handshake[i], offset++);
      }
    }
    return buff;
  },
  [11 /* ERROR */]: (code, message = "") => {
    const bytes = [11 /* ERROR */];
    encode.number(bytes, code);
    encode.string(bytes, message);
    return bytes;
  },
  [14 /* ROOM_STATE */]: (bytes) => {
    return [14 /* ROOM_STATE */, ...bytes];
  },
  [16 /* ROOM_DATA_SCHEMA */]: (message) => {
    const typeid = message.constructor._typeid;
    if (typeid === void 0) {
      logger.warn("Starting at colyseus >= 0.13 You must provide a type and message when calling `this.broadcast()` or `client.send()`. Please see: https://docs.colyseus.io/migrating/0.13/");
      throw new Error(`an instance of Schema was expected, but ${JSON.stringify(message)} has been provided.`);
    }
    return [16 /* ROOM_DATA_SCHEMA */, typeid, ...message.encodeAll()];
  },
  raw: (code, type, message, rawMessage) => {
    const initialBytes = [code];
    const messageType = typeof type;
    if (messageType === "string") {
      encode.string(initialBytes, type);
    } else if (messageType === "number") {
      encode.number(initialBytes, type);
    } else {
      throw new Error(`Protocol.ROOM_DATA: message type not supported "${type.toString()}"`);
    }
    let arr;
    if (message !== void 0) {
      const encoded = pack(message);
      arr = new Uint8Array(initialBytes.length + encoded.byteLength);
      arr.set(new Uint8Array(initialBytes), 0);
      arr.set(new Uint8Array(encoded), initialBytes.length);
    } else if (rawMessage !== void 0) {
      arr = new Uint8Array(initialBytes.length + (rawMessage.byteLength || rawMessage.length));
      arr.set(new Uint8Array(initialBytes), 0);
      arr.set(new Uint8Array(rawMessage), initialBytes.length);
    } else {
      arr = new Uint8Array(initialBytes);
    }
    return arr;
  }
};
function utf8Write(buff, offset, str = "") {
  buff[offset++] = utf8Length(str) - 1;
  let c = 0;
  for (let i = 0, l = str.length; i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 128) {
      buff[offset++] = c;
    } else if (c < 2048) {
      buff[offset++] = 192 | c >> 6;
      buff[offset++] = 128 | c & 63;
    } else if (c < 55296 || c >= 57344) {
      buff[offset++] = 224 | c >> 12;
      buff[offset++] = 128 | c >> 6 & 63;
      buff[offset++] = 128 | c & 63;
    } else {
      i++;
      c = 65536 + ((c & 1023) << 10 | str.charCodeAt(i) & 1023);
      buff[offset++] = 240 | c >> 18;
      buff[offset++] = 128 | c >> 12 & 63;
      buff[offset++] = 128 | c >> 6 & 63;
      buff[offset++] = 128 | c & 63;
    }
  }
}
function utf8Length(str = "") {
  let c = 0;
  let length = 0;
  for (let i = 0, l = str.length; i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 128) {
      length += 1;
    } else if (c < 2048) {
      length += 2;
    } else if (c < 55296 || c >= 57344) {
      length += 3;
    } else {
      i++;
      length += 4;
    }
  }
  return length + 1;
}
export {
  ErrorCode,
  IpcProtocol,
  Protocol,
  getMessageBytes,
  utf8Length,
  utf8Write
};
