{
  "version": 3,
  "sources": ["../src/IPC.ts"],
  "sourcesContent": ["import { debugAndPrintError } from './Debug';\nimport { Presence } from './presence/Presence';\nimport { IpcProtocol } from './Protocol';\nimport { generateId, REMOTE_ROOM_SHORT_TIMEOUT } from './utils/Utils';\n\nexport async function requestFromIPC<T>(\n  presence: Presence,\n  publishToChannel: string,\n  method: string,\n  args: any[],\n  rejectionTimeout: number = REMOTE_ROOM_SHORT_TIMEOUT,\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    let unsubscribeTimeout: NodeJS.Timer;\n\n    const requestId = generateId();\n    const channel = `ipc:${requestId}`;\n\n    const unsubscribe = () => {\n      presence.unsubscribe(channel);\n      clearTimeout(unsubscribeTimeout);\n    };\n\n    presence.subscribe(channel, (message) => {\n      const [code, data] = message;\n      if (code === IpcProtocol.SUCCESS) {\n        resolve(data);\n      } else if (code === IpcProtocol.ERROR) {\n        reject(data);\n      }\n      unsubscribe();\n    });\n\n    presence.publish(publishToChannel, [method, requestId, args]);\n\n    unsubscribeTimeout = setTimeout(() => {\n      unsubscribe();\n      reject(`IPC timed out. method: ${method}, args: ${JSON.stringify(args)}`);\n    }, rejectionTimeout);\n  });\n}\n\nexport async function subscribeIPC(\n  presence: Presence,\n  processId: string,\n  channel: string,\n  replyCallback: (method: string, args: any[]) => any,\n) {\n  await presence.subscribe(channel, (message) => {\n    const [method, requestId, args] = message;\n\n    const reply = (code, data) => {\n      presence.publish(`ipc:${requestId}`, [code, data]);\n    };\n\n    // reply with method result\n    let response: any;\n    try {\n      response = replyCallback(method, args);\n\n    } catch (e) {\n      debugAndPrintError(e);\n      return reply(IpcProtocol.ERROR, e.message || e);\n    }\n\n    if (!(response instanceof Promise)) {\n      return reply(IpcProtocol.SUCCESS, response);\n    }\n\n    response.\n      then((result) => reply(IpcProtocol.SUCCESS, result)).\n      catch((e) => {\n        // user might have called `reject()` without arguments.\n        const err = e && e.message || e;\n        reply(IpcProtocol.ERROR, err);\n      });\n  });\n}\n"],
  "mappings": "AAAA,SAAS,0BAA0B;AAEnC,SAAS,mBAAmB;AAC5B,SAAS,YAAY,iCAAiC;AAEtD,eAAsB,eACpB,UACA,kBACA,QACA,MACA,mBAA2B,2BACf;AACZ,SAAO,IAAI,QAAW,CAAC,SAAS,WAAW;AACzC,QAAI;AAEJ,UAAM,YAAY,WAAW;AAC7B,UAAM,UAAU,OAAO;AAEvB,UAAM,cAAc,MAAM;AACxB,eAAS,YAAY,OAAO;AAC5B,mBAAa,kBAAkB;AAAA,IACjC;AAEA,aAAS,UAAU,SAAS,CAAC,YAAY;AACvC,YAAM,CAAC,MAAM,IAAI,IAAI;AACrB,UAAI,SAAS,YAAY,SAAS;AAChC,gBAAQ,IAAI;AAAA,MACd,WAAW,SAAS,YAAY,OAAO;AACrC,eAAO,IAAI;AAAA,MACb;AACA,kBAAY;AAAA,IACd,CAAC;AAED,aAAS,QAAQ,kBAAkB,CAAC,QAAQ,WAAW,IAAI,CAAC;AAE5D,yBAAqB,WAAW,MAAM;AACpC,kBAAY;AACZ,aAAO,0BAA0B,iBAAiB,KAAK,UAAU,IAAI,GAAG;AAAA,IAC1E,GAAG,gBAAgB;AAAA,EACrB,CAAC;AACH;AAEA,eAAsB,aACpB,UACA,WACA,SACA,eACA;AACA,QAAM,SAAS,UAAU,SAAS,CAAC,YAAY;AAC7C,UAAM,CAAC,QAAQ,WAAW,IAAI,IAAI;AAElC,UAAM,QAAQ,CAAC,MAAM,SAAS;AAC5B,eAAS,QAAQ,OAAO,aAAa,CAAC,MAAM,IAAI,CAAC;AAAA,IACnD;AAGA,QAAI;AACJ,QAAI;AACF,iBAAW,cAAc,QAAQ,IAAI;AAAA,IAEvC,SAAS,GAAP;AACA,yBAAmB,CAAC;AACpB,aAAO,MAAM,YAAY,OAAO,EAAE,WAAW,CAAC;AAAA,IAChD;AAEA,QAAI,EAAE,oBAAoB,UAAU;AAClC,aAAO,MAAM,YAAY,SAAS,QAAQ;AAAA,IAC5C;AAEA,aACE,KAAK,CAAC,WAAW,MAAM,YAAY,SAAS,MAAM,CAAC,EACnD,MAAM,CAAC,MAAM;AAEX,YAAM,MAAM,KAAK,EAAE,WAAW;AAC9B,YAAM,YAAY,OAAO,GAAG;AAAA,IAC9B,CAAC;AAAA,EACL,CAAC;AACH;",
  "names": []
}
