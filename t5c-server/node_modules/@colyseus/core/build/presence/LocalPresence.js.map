{
  "version": 3,
  "sources": ["../../src/presence/LocalPresence.ts"],
  "sourcesContent": ["import fs from \"fs\";\nimport path from \"path\";\n\nimport { EventEmitter } from 'events';\nimport { spliceOne } from '../utils/Utils';\nimport { Presence } from './Presence';\n\nimport { isDevMode } from '../utils/DevMode';\n\ntype Callback = (...args: any[]) => void;\n\nconst DEVMODE_CACHE_FILE_PATH = path.resolve(\".devmode.json\");\n\nexport class LocalPresence implements Presence {\n    public channels = new EventEmitter();\n\n    public data: {[roomName: string]: string[]} = {};\n    public hash: {[roomName: string]: {[key: string]: string}} = {};\n\n    public keys: {[name: string]: string | number} = {};\n\n    protected subscriptions: {[id: string]: Callback[]} = {};\n    private timeouts: {[name: string]: NodeJS.Timer} = {};\n\n    constructor() {\n      //\n      // reload from local cache on devMode\n      //\n      if (\n        isDevMode &&\n        fs.existsSync(DEVMODE_CACHE_FILE_PATH)\n      ) {\n        const cache = fs.readFileSync(DEVMODE_CACHE_FILE_PATH).toString('utf-8') || \"{}\";\n        const parsed = JSON.parse(cache);\n        this.data = parsed.data;\n        this.hash = parsed.hash;\n        this.keys = parsed.keys;\n      }\n    }\n\n    public subscribe(topic: string, callback: (...args: any[]) => void) {\n        if (!this.subscriptions[topic]) { this.subscriptions[topic] = []; }\n        this.subscriptions[topic].push(callback);\n        this.channels.on(topic, callback);\n        return this;\n    }\n\n    public unsubscribe(topic: string, callback?: Callback) {\n        const topicCallbacks = this.subscriptions[topic];\n        if (!topicCallbacks) { return; }\n\n        if (callback)  {\n            const idx = topicCallbacks.indexOf(callback);\n            if (idx !== -1) {\n                topicCallbacks.splice(idx, 1);\n                this.channels.removeListener(topic, callback);\n            }\n\n            if (topicCallbacks.length === 0) {\n                delete this.subscriptions[topic];\n            }\n\n        } else {\n          topicCallbacks.forEach((cb) =>\n            this.channels.removeListener(topic, cb));\n\n          delete this.subscriptions[topic];\n        }\n\n        return this;\n    }\n\n    public publish(topic: string, data: any) {\n        this.channels.emit(topic, data);\n        return this;\n    }\n\n    public async exists(roomId: string): Promise<boolean> {\n        return this.channels.listenerCount(roomId) > 0;\n    }\n\n    public set(key: string, value: string) {\n        this.keys[key] = value;\n    }\n\n    public setex(key: string, value: string, seconds: number) {\n        // ensure previous timeout is clear before setting another one.\n        if (this.timeouts[key]) {\n            clearTimeout(this.timeouts[key]);\n        }\n\n        this.keys[key] = value;\n        this.timeouts[key] = setTimeout(() => {\n            delete this.keys[key];\n            delete this.timeouts[key];\n        }, seconds * 1000);\n    }\n\n    public get(key: string) {\n        return this.keys[key];\n    }\n\n    public del(key: string) {\n        delete this.keys[key];\n        delete this.data[key];\n        delete this.hash[key];\n    }\n\n    public sadd(key: string, value: any) {\n        if (!this.data[key]) {\n            this.data[key] = [];\n        }\n\n        if (this.data[key].indexOf(value) === -1) {\n            this.data[key].push(value);\n        }\n    }\n\n    public async smembers(key: string): Promise<string[]> {\n        return this.data[key] || [];\n    }\n\n    public async sismember(key: string, field: string) {\n        return this.data[key] && this.data[key].includes(field) ? 1 : 0;\n    }\n\n    public srem(key: string, value: any) {\n        if (this.data[key]) {\n            spliceOne(this.data[key], this.data[key].indexOf(value));\n        }\n    }\n\n    public scard(key: string) {\n        return (this.data[key] || []).length;\n    }\n\n    public async sinter(...keys: string[]) {\n      const intersection: {[value: string]: number} = {};\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        (await this.smembers(keys[i])).forEach((member) => {\n          if (!intersection[member]) {\n            intersection[member] = 0;\n          }\n\n          intersection[member]++;\n        });\n      }\n\n      return Object.keys(intersection).reduce((prev, curr) => {\n        if (intersection[curr] > 1) {\n          prev.push(curr);\n        }\n        return prev;\n      }, []);\n    }\n\n    public hset(key: string, field: string, value: string) {\n        if (!this.hash[key]) { this.hash[key] = {}; }\n        this.hash[key][field] = value;\n    }\n\n    public hincrby(key: string, field: string, incrBy: number) {\n        if (!this.hash[key]) { this.hash[key] = {}; }\n        let value = Number(this.hash[key][field] || '0');\n        value += incrBy;\n        this.hash[key][field] = value.toString();\n        return value;\n    }\n\n    public async hget(key: string, field: string) {\n        return this.hash[key] && this.hash[key][field];\n    }\n\n    public async hgetall(key: string) {\n        return this.hash[key] || {};\n    }\n\n    public hdel(key: string, field: any) {\n        if (this.hash[key]) {\n            delete this.hash[key][field];\n        }\n    }\n\n    public async hlen(key: string) {\n        return this.hash[key] && Object.keys(this.hash[key]).length || 0;\n    }\n\n    public async incr(key: string) {\n        if (!this.keys[key]) {\n            this.keys[key] = 0;\n        }\n        (this.keys[key] as number)++;\n        return Promise.resolve(this.keys[key] as number);\n    }\n\n    public async decr(key: string) {\n        if (!this.keys[key]) {\n            this.keys[key] = 0;\n        }\n        (this.keys[key] as number)--;\n        return Promise.resolve(this.keys[key] as number);\n    }\n\n    public shutdown() {\n      if (isDevMode) {\n        const cache = JSON.stringify({\n          data: this.data,\n          hash: this.hash,\n          keys: this.keys\n        });\n        fs.writeFileSync(DEVMODE_CACHE_FILE_PATH, cache, { encoding: \"utf-8\" });\n      }\n    }\n\n}\n"],
  "mappings": "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",
  "names": ["path", "fs"]
}
