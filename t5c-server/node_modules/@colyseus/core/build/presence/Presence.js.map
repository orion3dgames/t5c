{
  "version": 3,
  "sources": ["../../src/presence/Presence.ts"],
  "sourcesContent": ["/**\n * When you need to scale your server on multiple processes and/or machines, you'd need to provide\n * the Presence option to the Server. The purpose of Presence is to allow communicating and\n * sharing data between different processes, specially during match-making.\n *\n * - Local presence - This is the default option. It's meant to be used when you're running Colyseus in\n *  a single process.\n * - Redis presence - Use this option when you're running Colyseus on multiple processes and/or machines.\n *\n * @default Local presence\n */\nexport interface Presence {\n    /**\n     * Subscribes to the given topic. The callback will be triggered whenever a message is published on topic.\n     *\n     * @param topic - Topic name.\n     * @param callback - Callback to trigger on subscribing.\n     */\n    subscribe(topic: string, callback: Function);\n    /**\n     * Unsubscribe from given topic.\n     *\n     * @param topic - Topic name.\n     * @param callback - Callback to trigger on topic unsubscribing.\n     */\n    unsubscribe(topic: string, callback?: Function);\n\n    /**\n     * Posts a message to given topic.\n     *\n     * @param topic - Topic name.\n     * @param data - Message body/object.\n     */\n    publish(topic: string, data: any);\n\n    /**\n     * Returns if key exists.\n     *\n     * @param roomId\n     */\n    exists(roomId: string): Promise<boolean>;\n\n    /**\n     * Set key to hold the string value.\n     *\n     * @param key - Identifier.\n     * @param value - Message body/object.\n     */\n    set(key: string, value: string);\n\n    /**\n     * Set key to hold the string value and set key to timeout after a given number of seconds.\n     *\n     * @param key - Identifier.\n     * @param value - Message body/object.\n     * @param seconds - Timeout value.\n     */\n    setex(key: string, value: string, seconds: number);\n\n    /**\n     * Get the value of key.\n     *\n     * @param key - Identifier.\n     */\n    get(key: string);\n\n    /**\n     * Removes the specified key.\n     *\n     * @param key - Identifier of the object to removed.\n     */\n    del(key: string): void;\n\n    /**\n     * Add the specified members to the set stored at key. Specified members that are already\n     * a member of this set are ignored. If key does not exist, a new set is created before\n     * adding the specified members.\n     *\n     * @param key - Name/Identifier of the set.\n     * @param value - Message body/object.\n     */\n    sadd(key: string, value: any);\n    /**\n     * Returns all the members of the set value stored at key.\n     *\n     * @param key - Name/Identifier of the set.\n     */\n    smembers(key: string): Promise<string[]>;\n    /**\n     * Returns if member is a member of the set stored at key.\n     *\n     * @param key - Name/Identifier of the set.\n     * @param field - Key value within the set.\n     * @returns `1` if the element is a member of the set else `0`.\n     */\n    sismember(key: string, field: string);\n    /**\n     * Remove the specified members from the set stored at key. Specified members that are not a\n     * member of this set are ignored. If key does not exist, it is treated as an empty set\n     * and this command returns 0.\n     *\n     * @param key -  Name/Identifier of the set.\n     * @param value - Key value within the set.\n     */\n    srem(key: string, value: any);\n    /**\n     * Returns the set cardinality (number of elements) of the set stored at key.\n     *\n     * @param key -  Name/Identifier of the set.\n     */\n    scard(key: string);\n    /**\n     * Returns the members of the set resulting from the intersection of all the given sets.\n     *\n     * @param keys - Key values within the set.\n     */\n    sinter(...keys: string[]): Promise<string[]>;\n\n    /**\n     * Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created.\n     * If field already exists in the hash, it is overwritten.\n     */\n    hset(key: string, field: string, value: string);\n\n    /**\n     * Increments the number stored at field in the hash stored at key by increment. If key does not exist, a new key\n     * holding a hash is created. If field does not exist the value is set to 0 before the operation is performed.\n     */\n    hincrby(key: string, field: string, value: number): number | Promise<number>;\n\n    /**\n     * Returns the value associated with field in the hash stored at key.\n     */\n    hget(key: string, field: string): Promise<string>;\n\n    /**\n     * Returns all fields and values of the hash stored at key.\n     */\n    hgetall(key: string): Promise<{ [key: string]: string }>;\n\n    /**\n     * Removes the specified fields from the hash stored at key. Specified fields that do not exist within\n     * this hash are ignored. If key does not exist, it is treated as an empty hash and this command returns 0.\n     */\n    hdel(key: string, field: string);\n\n    /**\n     * Returns the number of fields contained in the hash stored at key\n     */\n    hlen(key: string): Promise<number>;\n\n    /**\n     * Increments the number stored at key by one. If the key does not exist, it is set to 0 before performing\n     * the operation. An error is returned if the key contains a value of the wrong type or\n     * contains a string that can not be represented as integer. This operation is limited to 64-bit signed integers.\n     */\n    incr(key: string): Promise<number>;\n\n    /**\n     * Decrements the number stored at key by one. If the key does not exist, it is set to 0 before performing\n     * the operation. An error is returned if the key contains a value of the wrong type or contains a string\n     * that can not be represented as integer. This operation is limited to 64-bit signed integers.\n     */\n    decr(key: string): Promise<number>;\n\n    shutdown(): void;\n}\n"],
  "mappings": ";;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
