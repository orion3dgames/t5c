{
  "version": 3,
  "sources": ["../src/Protocol.ts"],
  "sourcesContent": ["import { pack } from 'msgpackr';\nimport { encode, Schema } from '@colyseus/schema';\nimport { logger } from './Logger';\n\n// Colyseus protocol codes range between 0~100\nexport enum Protocol {\n  // Room-related (10~19)\n  JOIN_ROOM = 10,\n  ERROR = 11,\n  LEAVE_ROOM = 12,\n  ROOM_DATA = 13,\n  ROOM_STATE = 14,\n  ROOM_STATE_PATCH = 15,\n  ROOM_DATA_SCHEMA = 16, // used to send schema instances via room.send()\n  ROOM_DATA_BYTES = 17,\n\n  // WebSocket close codes (https://github.com/Luka967/websocket-close-codes)\n  WS_CLOSE_NORMAL = 1000,\n\n  // WebSocket error codes\n  WS_CLOSE_CONSENTED = 4000,\n  WS_CLOSE_WITH_ERROR = 4002,\n  WS_CLOSE_DEVMODE_RESTART = 4010,\n\n  WS_SERVER_DISCONNECT = 4201,\n  WS_TOO_MANY_CLIENTS = 4202,\n}\n\nexport enum ErrorCode {\n  // MatchMaking Error Codes\n  MATCHMAKE_NO_HANDLER = 4210,\n  MATCHMAKE_INVALID_CRITERIA = 4211,\n  MATCHMAKE_INVALID_ROOM_ID = 4212,\n  MATCHMAKE_UNHANDLED = 4213, // generic exception during onCreate/onJoin\n  MATCHMAKE_EXPIRED = 4214, // generic exception during onCreate/onJoin\n\n  AUTH_FAILED = 4215,\n  APPLICATION_ERROR = 4216,\n}\n\n// Inter-process communication protocol\nexport enum IpcProtocol {\n  SUCCESS = 0,\n  ERROR = 1,\n  TIMEOUT = 2,\n}\n\nexport const getMessageBytes = {\n  [Protocol.JOIN_ROOM]: (reconnectionToken: string, serializerId: string, handshake?: number[]) => {\n    let offset = 0;\n\n    const reconnectionTokenLength = utf8Length(reconnectionToken);\n    const serializerIdLength = utf8Length(serializerId);\n    const handshakeLength = (handshake) ? handshake.length : 0;\n\n    const buff = Buffer.allocUnsafe(1 + reconnectionTokenLength + serializerIdLength + handshakeLength);\n    buff.writeUInt8(Protocol.JOIN_ROOM, offset++);\n\n    utf8Write(buff, offset, reconnectionToken);\n    offset += reconnectionTokenLength;\n\n    utf8Write(buff, offset, serializerId);\n    offset += serializerIdLength;\n\n    if (handshake) {\n      for (let i = 0, l = handshake.length; i < l; i++) {\n        buff.writeUInt8(handshake[i], offset++);\n      }\n    }\n\n    return buff;\n  },\n\n  [Protocol.ERROR]: (code: number, message: string = '') => {\n    const bytes = [Protocol.ERROR];\n\n    encode.number(bytes, code);\n    encode.string(bytes, message);\n\n    return bytes;\n  },\n\n  [Protocol.ROOM_STATE]: (bytes: number[]) => {\n    return [Protocol.ROOM_STATE, ...bytes];\n  },\n\n  [Protocol.ROOM_DATA_SCHEMA]: (message: Schema) => {\n    const typeid = (message.constructor as typeof Schema)._typeid;\n\n    if (typeid === undefined) {\n      logger.warn('Starting at colyseus >= 0.13 You must provide a type and message when calling `this.broadcast()` or `client.send()`. Please see: https://docs.colyseus.io/migrating/0.13/');\n      throw new Error(`an instance of Schema was expected, but ${JSON.stringify(message)} has been provided.`);\n    }\n\n    return [Protocol.ROOM_DATA_SCHEMA, typeid, ...message.encodeAll()];\n  },\n\n  raw: (code: Protocol, type: string | number, message?: any, rawMessage?: ArrayLike<number> | Buffer) => {\n    const initialBytes: number[] = [code];\n    const messageType = typeof (type);\n\n    if (messageType === 'string') {\n      encode.string(initialBytes, type);\n\n    } else if (messageType === 'number') {\n      encode.number(initialBytes, type);\n\n    } else {\n      throw new Error(`Protocol.ROOM_DATA: message type not supported \"${type.toString()}\"`);\n    }\n\n    let arr: Uint8Array;\n\n    if (message !== undefined) {\n      const encoded = pack(message);\n      arr = new Uint8Array(initialBytes.length + encoded.byteLength);\n      arr.set(new Uint8Array(initialBytes), 0);\n      arr.set(new Uint8Array(encoded), initialBytes.length);\n\n    } else if (rawMessage !== undefined) {\n      arr = new Uint8Array(initialBytes.length + ((rawMessage as Buffer).byteLength || rawMessage.length));\n      arr.set(new Uint8Array(initialBytes), 0);\n      arr.set(new Uint8Array(rawMessage), initialBytes.length);\n\n    } else {\n      arr = new Uint8Array(initialBytes);\n    }\n\n    return arr;\n  },\n\n};\n\nexport function utf8Write(buff: Buffer, offset: number, str: string = '') {\n  buff[offset++] = utf8Length(str) - 1;\n\n  let c = 0;\n  for (let i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n    if (c < 0x80) {\n      buff[offset++] = c;\n    } else if (c < 0x800) {\n      buff[offset++] = 0xc0 | (c >> 6);\n      buff[offset++] = 0x80 | (c & 0x3f);\n    } else if (c < 0xd800 || c >= 0xe000) {\n      buff[offset++] = 0xe0 | (c >> 12);\n      buff[offset++] = 0x80 | (c >> 6) & 0x3f;\n      buff[offset++] = 0x80 | (c & 0x3f);\n    } else {\n      i++;\n      c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n      buff[offset++] = 0xf0 | (c >> 18);\n      buff[offset++] = 0x80 | (c >> 12) & 0x3f;\n      buff[offset++] = 0x80 | (c >> 6) & 0x3f;\n      buff[offset++] = 0x80 | (c & 0x3f);\n    }\n  }\n}\n\n// Faster for short strings than Buffer.byteLength\nexport function utf8Length(str: string = '') {\n  let c = 0;\n  let length = 0;\n  for (let i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n    if (c < 0x80) {\n      length += 1;\n    } else if (c < 0x800) {\n      length += 2;\n    } else if (c < 0xd800 || c >= 0xe000) {\n      length += 3;\n    } else {\n      i++;\n      length += 4;\n    }\n  }\n  return length + 1;\n}\n"],
  "mappings": "AAAA,SAAS,YAAY;AACrB,SAAS,cAAsB;AAC/B,SAAS,cAAc;AAGhB,IAAK,WAAL,kBAAKA,cAAL;AAEL,EAAAA,oBAAA,eAAY,MAAZ;AACA,EAAAA,oBAAA,WAAQ,MAAR;AACA,EAAAA,oBAAA,gBAAa,MAAb;AACA,EAAAA,oBAAA,eAAY,MAAZ;AACA,EAAAA,oBAAA,gBAAa,MAAb;AACA,EAAAA,oBAAA,sBAAmB,MAAnB;AACA,EAAAA,oBAAA,sBAAmB,MAAnB;AACA,EAAAA,oBAAA,qBAAkB,MAAlB;AAGA,EAAAA,oBAAA,qBAAkB,OAAlB;AAGA,EAAAA,oBAAA,wBAAqB,OAArB;AACA,EAAAA,oBAAA,yBAAsB,QAAtB;AACA,EAAAA,oBAAA,8BAA2B,QAA3B;AAEA,EAAAA,oBAAA,0BAAuB,QAAvB;AACA,EAAAA,oBAAA,yBAAsB,QAAtB;AApBU,SAAAA;AAAA,GAAA;AAuBL,IAAK,YAAL,kBAAKC,eAAL;AAEL,EAAAA,sBAAA,0BAAuB,QAAvB;AACA,EAAAA,sBAAA,gCAA6B,QAA7B;AACA,EAAAA,sBAAA,+BAA4B,QAA5B;AACA,EAAAA,sBAAA,yBAAsB,QAAtB;AACA,EAAAA,sBAAA,uBAAoB,QAApB;AAEA,EAAAA,sBAAA,iBAAc,QAAd;AACA,EAAAA,sBAAA,uBAAoB,QAApB;AATU,SAAAA;AAAA,GAAA;AAaL,IAAK,cAAL,kBAAKC,iBAAL;AACL,EAAAA,0BAAA,aAAU,KAAV;AACA,EAAAA,0BAAA,WAAQ,KAAR;AACA,EAAAA,0BAAA,aAAU,KAAV;AAHU,SAAAA;AAAA,GAAA;AAML,MAAM,kBAAkB;AAAA,EAC7B,CAAC,qBAAqB,CAAC,mBAA2B,cAAsB,cAAyB;AAC/F,QAAI,SAAS;AAEb,UAAM,0BAA0B,WAAW,iBAAiB;AAC5D,UAAM,qBAAqB,WAAW,YAAY;AAClD,UAAM,kBAAmB,YAAa,UAAU,SAAS;AAEzD,UAAM,OAAO,OAAO,YAAY,IAAI,0BAA0B,qBAAqB,eAAe;AAClG,SAAK,WAAW,oBAAoB,QAAQ;AAE5C,cAAU,MAAM,QAAQ,iBAAiB;AACzC,cAAU;AAEV,cAAU,MAAM,QAAQ,YAAY;AACpC,cAAU;AAEV,QAAI,WAAW;AACb,eAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,IAAI,GAAG,KAAK;AAChD,aAAK,WAAW,UAAU,IAAI,QAAQ;AAAA,MACxC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,CAAC,iBAAiB,CAAC,MAAc,UAAkB,OAAO;AACxD,UAAM,QAAQ,CAAC,cAAc;AAE7B,WAAO,OAAO,OAAO,IAAI;AACzB,WAAO,OAAO,OAAO,OAAO;AAE5B,WAAO;AAAA,EACT;AAAA,EAEA,CAAC,sBAAsB,CAAC,UAAoB;AAC1C,WAAO,CAAC,qBAAqB,GAAG,KAAK;AAAA,EACvC;AAAA,EAEA,CAAC,4BAA4B,CAAC,YAAoB;AAChD,UAAM,SAAU,QAAQ,YAA8B;AAEtD,QAAI,WAAW,QAAW;AACxB,aAAO,KAAK,2KAA2K;AACvL,YAAM,IAAI,MAAM,2CAA2C,KAAK,UAAU,OAAO,sBAAsB;AAAA,IACzG;AAEA,WAAO,CAAC,2BAA2B,QAAQ,GAAG,QAAQ,UAAU,CAAC;AAAA,EACnE;AAAA,EAEA,KAAK,CAAC,MAAgB,MAAuB,SAAe,eAA4C;AACtG,UAAM,eAAyB,CAAC,IAAI;AACpC,UAAM,cAAc,OAAQ;AAE5B,QAAI,gBAAgB,UAAU;AAC5B,aAAO,OAAO,cAAc,IAAI;AAAA,IAElC,WAAW,gBAAgB,UAAU;AACnC,aAAO,OAAO,cAAc,IAAI;AAAA,IAElC,OAAO;AACL,YAAM,IAAI,MAAM,mDAAmD,KAAK,SAAS,IAAI;AAAA,IACvF;AAEA,QAAI;AAEJ,QAAI,YAAY,QAAW;AACzB,YAAM,UAAU,KAAK,OAAO;AAC5B,YAAM,IAAI,WAAW,aAAa,SAAS,QAAQ,UAAU;AAC7D,UAAI,IAAI,IAAI,WAAW,YAAY,GAAG,CAAC;AACvC,UAAI,IAAI,IAAI,WAAW,OAAO,GAAG,aAAa,MAAM;AAAA,IAEtD,WAAW,eAAe,QAAW;AACnC,YAAM,IAAI,WAAW,aAAa,UAAW,WAAsB,cAAc,WAAW,OAAO;AACnG,UAAI,IAAI,IAAI,WAAW,YAAY,GAAG,CAAC;AACvC,UAAI,IAAI,IAAI,WAAW,UAAU,GAAG,aAAa,MAAM;AAAA,IAEzD,OAAO;AACL,YAAM,IAAI,WAAW,YAAY;AAAA,IACnC;AAEA,WAAO;AAAA,EACT;AAEF;AAEO,SAAS,UAAU,MAAc,QAAgB,MAAc,IAAI;AACxE,OAAK,YAAY,WAAW,GAAG,IAAI;AAEnC,MAAI,IAAI;AACR,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,IAAI,GAAG,KAAK;AAC1C,QAAI,IAAI,WAAW,CAAC;AACpB,QAAI,IAAI,KAAM;AACZ,WAAK,YAAY;AAAA,IACnB,WAAW,IAAI,MAAO;AACpB,WAAK,YAAY,MAAQ,KAAK;AAC9B,WAAK,YAAY,MAAQ,IAAI;AAAA,IAC/B,WAAW,IAAI,SAAU,KAAK,OAAQ;AACpC,WAAK,YAAY,MAAQ,KAAK;AAC9B,WAAK,YAAY,MAAQ,KAAK,IAAK;AACnC,WAAK,YAAY,MAAQ,IAAI;AAAA,IAC/B,OAAO;AACL;AACA,UAAI,UAAa,IAAI,SAAU,KAAO,IAAI,WAAW,CAAC,IAAI;AAC1D,WAAK,YAAY,MAAQ,KAAK;AAC9B,WAAK,YAAY,MAAQ,KAAK,KAAM;AACpC,WAAK,YAAY,MAAQ,KAAK,IAAK;AACnC,WAAK,YAAY,MAAQ,IAAI;AAAA,IAC/B;AAAA,EACF;AACF;AAGO,SAAS,WAAW,MAAc,IAAI;AAC3C,MAAI,IAAI;AACR,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,IAAI,GAAG,KAAK;AAC1C,QAAI,IAAI,WAAW,CAAC;AACpB,QAAI,IAAI,KAAM;AACZ,gBAAU;AAAA,IACZ,WAAW,IAAI,MAAO;AACpB,gBAAU;AAAA,IACZ,WAAW,IAAI,SAAU,KAAK,OAAQ;AACpC,gBAAU;AAAA,IACZ,OAAO;AACL;AACA,gBAAU;AAAA,IACZ;AAAA,EACF;AACA,SAAO,SAAS;AAClB;",
  "names": ["Protocol", "ErrorCode", "IpcProtocol"]
}
