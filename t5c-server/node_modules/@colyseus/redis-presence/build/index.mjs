import Redis, { Cluster } from "ioredis";
class RedisPresence {
  sub;
  pub;
  subscriptions = {};
  constructor(options, clusterOptions) {
    if (Array.isArray(options)) {
      this.sub = new Cluster(options, clusterOptions);
      this.sub = new Cluster(options, clusterOptions);
    } else {
      this.sub = new Redis(options);
      this.pub = new Redis(options);
    }
    this.sub.setMaxListeners(0);
  }
  async subscribe(topic, callback) {
    if (!this.subscriptions[topic]) {
      this.subscriptions[topic] = [];
    }
    this.subscriptions[topic].push(callback);
    if (this.sub.listeners("message").length === 0) {
      this.sub.on("message", this.handleSubscription);
    }
    await this.sub.subscribe(topic);
    return this;
  }
  async unsubscribe(topic, callback) {
    const topicCallbacks = this.subscriptions[topic];
    if (!topicCallbacks) {
      return;
    }
    if (callback) {
      const index = topicCallbacks.indexOf(callback);
      topicCallbacks.splice(index, 1);
    } else {
      this.subscriptions[topic] = [];
    }
    if (this.subscriptions[topic].length === 0) {
      delete this.subscriptions[topic];
      await this.sub.unsubscribe(topic);
    }
    return this;
  }
  async publish(topic, data) {
    if (data === void 0) {
      data = false;
    }
    await this.pub.publish(topic, JSON.stringify(data));
  }
  async exists(roomId) {
    return (await this.pub.pubsub("channels", roomId)).length > 0;
  }
  async set(key, value) {
    return new Promise((resolve) => this.pub.set(key, value, resolve));
  }
  async setex(key, value, seconds) {
    return new Promise((resolve) => this.pub.setex(key, seconds, value, resolve));
  }
  async get(key) {
    return new Promise((resolve, reject) => {
      this.pub.get(key, (err, data) => {
        if (err) {
          return reject(err);
        }
        resolve(data);
      });
    });
  }
  async del(roomId) {
    return new Promise((resolve) => {
      this.pub.del(roomId, resolve);
    });
  }
  async sadd(key, value) {
    return new Promise((resolve) => {
      this.pub.sadd(key, value, resolve);
    });
  }
  async smembers(key) {
    return await this.pub.smembers(key);
  }
  async sismember(key, field) {
    return await this.pub.sismember(key, field);
  }
  async srem(key, value) {
    return await this.pub.srem(key, value);
  }
  async scard(key) {
    return await this.pub.scard(key);
  }
  async sinter(...keys) {
    return await this.pub.sinter(...keys);
  }
  async hset(key, field, value) {
    return await this.pub.hset(key, field, value);
  }
  async hincrby(key, field, value) {
    return new Promise((resolve, reject) => {
      this.pub.hincrby(key, field, value, (err, result) => {
        if (err)
          return reject(err);
        resolve(result);
      });
    });
  }
  async hget(key, field) {
    return await this.pub.hget(key, field);
  }
  async hgetall(key) {
    return await this.pub.hgetall(key);
  }
  async hdel(key, field) {
    return await this.pub.hdel(key, field);
  }
  async hlen(key) {
    return await this.pub.hlen(key);
  }
  async incr(key) {
    return await this.pub.incr(key);
  }
  async decr(key) {
    return await this.pub.decr(key);
  }
  shutdown() {
    this.sub.quit();
    this.pub.quit();
  }
  handleSubscription = (channel, message) => {
    if (this.subscriptions[channel]) {
      for (let i = 0, l = this.subscriptions[channel].length; i < l; i++) {
        this.subscriptions[channel][i](JSON.parse(message));
      }
    }
  };
}
export {
  RedisPresence
};
