{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../src/codegen/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\";\nimport * as path from \"path\";\nimport {readFileSync} from \"fs\";\nimport {IStructure, Class, Interface, Property, Context, Enum} from \"./types\";\n\nlet currentStructure: IStructure;\nlet currentProperty: Property;\n\nlet globalContext: Context;\n\nfunction defineProperty(property: Property, initializer: any) {\n    if (ts.isIdentifier(initializer)) {\n        property.type = \"ref\";\n        property.childType = initializer.text;\n\n    } else if (initializer.kind == ts.SyntaxKind.ObjectLiteralExpression) {\n        property.type = initializer.properties[0].name.text;\n        property.childType = initializer.properties[0].initializer.text;\n\n    } else if (initializer.kind == ts.SyntaxKind.ArrayLiteralExpression) {\n        property.type = \"array\";\n        property.childType = initializer.elements[0].text;\n\n    } else {\n        property.type = initializer.text;\n    }\n}\n\nfunction inspectNode(node: ts.Node, context: Context, decoratorName: string) {\n    switch (node.kind) {\n        case ts.SyntaxKind.ImportClause:\n            const specifier = (node.parent as any).moduleSpecifier;\n            if (specifier && (specifier.text as string).startsWith('.')) {\n                const currentDir = path.dirname(node.getSourceFile().fileName);\n                const pathToImport = path.resolve(currentDir, specifier.text);\n                parseFiles([pathToImport], decoratorName, globalContext);\n            }\n            break;\n\n        case ts.SyntaxKind.ClassDeclaration:\n            currentStructure = new Class();\n\n            const heritageClauses = (node as ts.ClassLikeDeclarationBase).heritageClauses;\n            if (heritageClauses && heritageClauses.length > 0) {\n                (currentStructure as Class).extends = heritageClauses[0].types[0].expression.getText();\n            }\n\n            context.addStructure(currentStructure);\n            break;\n\n        case ts.SyntaxKind.InterfaceDeclaration:\n            //\n            // Only generate Interfaces if it has \"Message\" on its name.\n            // Example: MyMessage\n            //\n            const interfaceName = (node as ts.TypeParameterDeclaration).name.escapedText.toString();\n            if (interfaceName.indexOf(\"Message\") !== -1) {\n                currentStructure = new Interface();\n                currentStructure.name = interfaceName;\n\n                context.addStructure(currentStructure);\n            }\n            break;\n\n        case ts.SyntaxKind.EnumDeclaration:\n            const enumName = (\n                node as ts.EnumDeclaration\n            ).name.escapedText.toString();\n            currentStructure = new Enum();\n            currentStructure.name = enumName;\n            context.addStructure(currentStructure);\n            break;\n\n        case ts.SyntaxKind.ExtendsKeyword:\n            // console.log(node.getText());\n            break;\n\n        case ts.SyntaxKind.PropertySignature:\n            if (currentStructure instanceof Interface) {\n                const interfaceDeclaration = node.parent;\n\n                if (\n                    currentStructure.name !== (interfaceDeclaration as ts.TypeParameterDeclaration).name.escapedText.toString()\n                ) {\n                    // skip if property if for a another interface than the one we're interested in.\n                    break;\n                }\n\n                // define a property of an interface\n                const property = new Property();\n                property.name = (node as any).name.escapedText.toString();\n                property.type = (node as any).type.getText();\n                currentStructure.addProperty(property);\n            }\n            break;\n\n        case ts.SyntaxKind.Identifier:\n            if (\n                node.getText() === \"deprecated\" &&\n                node.parent.kind !== ts.SyntaxKind.ImportSpecifier\n            ) {\n                currentProperty = new Property();\n                currentProperty.deprecated = true;\n                break;\n            }\n\n            if (node.getText() === decoratorName) {\n                const prop: any = node.parent?.parent?.parent;\n                const propDecorator = getDecorators(prop);\n                const hasExpression = prop?.expression?.arguments;\n                const hasDecorator = (propDecorator?.length > 0);\n\n                /**\n                 * neither a `@type()` decorator or `type()` call. skip.\n                 */\n                if (!hasDecorator && !hasExpression) {\n                    break;\n                }\n\n                // using as decorator\n                if (propDecorator) {\n                    /**\n                     * Calling `@type()` as decorator\n                     */\n                    const typeDecorator: any = propDecorator.find((decorator => {\n                        return (decorator.expression as any).expression.escapedText === decoratorName;\n                    })).expression;\n\n                    const property = currentProperty || new Property();\n                    property.name = prop.name.escapedText;\n                    currentStructure.addProperty(property);\n\n                    const typeArgument = typeDecorator.arguments[0];\n                    defineProperty(property, typeArgument);\n\n                } else if (\n                    prop.expression.arguments?.[1] &&\n                    prop.expression.expression.arguments?.[0]\n                ) {\n                    /**\n                     * Calling `type()` as a regular method\n                     */\n                    const property = currentProperty || new Property();\n                    property.name = prop.expression.arguments[1].text;\n                    currentStructure.addProperty(property);\n\n                    const typeArgument = prop.expression.expression.arguments[0];\n                    defineProperty(property, typeArgument);\n                }\n\n\n            } else if (\n                node.getText() === \"defineTypes\" &&\n                (\n                    node.parent.kind === ts.SyntaxKind.CallExpression ||\n                    node.parent.kind === ts.SyntaxKind.PropertyAccessExpression\n                )\n            ) {\n                /**\n                 * JavaScript source file (`.js`)\n                 * Using `defineTypes()`\n                 */\n                const callExpression = (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)\n                    ? node.parent.parent as ts.CallExpression\n                    : node.parent as ts.CallExpression;\n\n                if (callExpression.kind !== ts.SyntaxKind.CallExpression) {\n                    break;\n                }\n\n                const className = callExpression.arguments[0].getText()\n                currentStructure.name = className;\n\n                const types = callExpression.arguments[1] as any;\n                for (let i = 0; i < types.properties.length; i++) {\n                    const prop = types.properties[i];\n\n                    const property = currentProperty || new Property();\n                    property.name = prop.name.escapedText;\n                    currentStructure.addProperty(property);\n\n                    defineProperty(property, prop.initializer);\n                }\n\n            }\n\n            if (node.parent.kind === ts.SyntaxKind.ClassDeclaration) {\n                currentStructure.name = node.getText();\n            }\n\n            currentProperty = undefined;\n\n            break;\n\n        case ts.SyntaxKind.EnumMember:\n            if (currentStructure instanceof Enum) {\n                const initializer = (node as any).initializer?.getText();\n                const name = node.getFirstToken().getText();\n                const property = currentProperty || new Property();\n                property.name = name;\n                if (initializer !== undefined) {\n                    property.type = initializer;\n                }\n                currentStructure.addProperty(property);\n                currentProperty = undefined;\n            }\n            break;\n    }\n\n    ts.forEachChild(node, (n) => inspectNode(n, context, decoratorName));\n}\n\nlet parsedFiles: { [filename: string]: boolean };\n\nexport function parseFiles(\n    fileNames: string[],\n    decoratorName: string = \"type\",\n    context: Context = new Context()\n) {\n    /**\n     * Re-set globalContext for each test case\n     */\n    if (globalContext !== context) {\n        parsedFiles = {};\n        globalContext = context;\n    }\n\n    fileNames.forEach((fileName) => {\n        let sourceFile: ts.Node;\n        let sourceFileName: string;\n\n        const fileNameAlternatives = [];\n\n        if (\n            !fileName.endsWith(\".ts\") &&\n            !fileName.endsWith(\".js\") &&\n            !fileName.endsWith(\".mjs\")\n        ) {\n            fileNameAlternatives.push(`${fileName}.ts`);\n            fileNameAlternatives.push(`${fileName}/index.ts`);\n\n        } else {\n            fileNameAlternatives.push(fileName);\n        }\n\n        for (let i = 0; i < fileNameAlternatives.length; i++) {\n            try {\n                sourceFileName = path.resolve(fileNameAlternatives[i]);\n\n                if (parsedFiles[sourceFileName]) {\n                    break;\n                }\n\n                sourceFile = ts.createSourceFile(\n                    sourceFileName,\n                    readFileSync(sourceFileName).toString(),\n                    ts.ScriptTarget.Latest,\n                    true\n                );\n\n                parsedFiles[sourceFileName] = true;\n\n                break;\n            } catch (e) {\n                // console.log(`${fileNameAlternatives[i]} => ${e.message}`);\n            }\n        }\n\n        if (sourceFile) {\n            inspectNode(sourceFile, context, decoratorName);\n        }\n    });\n\n    return context.getStructures();\n}\n\n/**\n * TypeScript 4.8+ has introduced a change on how to access decorators.\n * - https://github.com/microsoft/TypeScript/pull/49089\n * - https://devblogs.microsoft.com/typescript/announcing-typescript-4-8/#decorators-are-placed-on-modifiers-on-typescripts-syntax-trees\n */\nexport function getDecorators(node: ts.Node | null | undefined,): undefined | ts.Decorator[] {\n    if (node == undefined) { return undefined; }\n\n    // TypeScript 4.7 and below\n    // @ts-ignore\n    if (node.decorators) { return node.decorators; }\n\n    // TypeScript 4.8 and above\n    // @ts-ignore\n    if (ts.canHaveDecorators && ts.canHaveDecorators(node)) {\n        // @ts-ignore\n        const decorators = ts.getDecorators(node);\n        return decorators ? Array.from(decorators) : undefined;\n    }\n\n    // @ts-ignore\n    return node.modifiers?.filter(ts.isDecorator);\n}\n"]}